#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# generated by wxGlade 0.9.6 on Thu Oct 29 22:41:10 2020
#

import math
import numpy as np

# Dimension
ly = 10.0 # m
fc = 35.0 # N/mm2
wd = 11.2 # kN/m2

span = np.array([10.0,10.0,10.0,10.0])
tslab = np.array([0.25,0.25,0.25,0.25])
tdrop = np.array([0.5,0.5,0.5,0.5,0.5])

htop = 3.2 #m
hbot = 3.2 #m

cx   = np.array([0.5,0.6,0.6,0.6,0.5])
cy   = np.array([0.5,0.6,0.6,0.6,0.5])
x    = np.array([0.5,0.5,0.5,0.5,0.5])

k_slab = 7.89 * ly*tslab**3/12/span # 7.89 from pca
k_col =  4.20 * cy*cx**3/12* ( 1.0/hbot + 1.0/htop ) # 4.20 just assumption
c = 9.0*( 1.0-0.63*x/cx)*(x**3*cx/3) / ly/ (1.0-cy/ly)**3 # totional stiff
kec = 1.0/(1.0/k_col+1.0/c) # equivalent column

print("Kb  =",k_slab)
print("Kcol=",k_col)
print("Ktos=",c)
print("Kec =",kec)

df = []
for i in range(0,len(kec)):
    if i == 0 :
        df.append( k_slab[i]/(k_slab[i]+kec[i]) )
    elif i == len(kec)-1:
        df.append( k_slab[i-1]/(k_slab[i-1]+kec[i]) )
    else:
        df.append( k_slab[i-1]/(k_slab[i-1]+k_slab[i]+kec[i]) )
        df.append( k_slab[i]/(k_slab[i-1]+k_slab[i]+kec[i]) )

# cof assumption # 0.66 from PCA
cof = []
for i in range(0,len(span)):
    cof.append( 0.66 )
    cof.append( 0.66 )

fem = []
for i in range(0,len(span)): # 0.0993 from PCA
    if i == 0 or i == len(span)-1:
        fem.append(  0.0993*wd*ly * span[i]**2 )
        fem.append( -0.0993*wd*ly * span[i]**2 )
#        fem.append(  0.0993*(wd-2.0)*ly * span[i]**2 )
#        fem.append(  -0.0993*(wd-2.0)*ly * span[i]**2 )
    else:
        fem.append(  0.0993*wd*ly * span[i]**2 )
        fem.append( -0.0993*wd*ly * span[i]**2 )

# EFM calculation
#df  = [0.551,  0.355, 0.355,  0.355, 0.355,  0.355, 0.355, 0.551]
#cof = [0.578,  0.578, 0.578,  0.578, 0.578,  0.578, 0.578, 0.578]
#fem = [677.6, -677.6, 677.6, -677.6, 677.6, -677.6, 677.6, -677.6]

#print(len(df),len(cof),len(fem))

n = int(len(df)/2)+1
n2 = 2*n-2


# initial calculation
cal = []

fem2 = []
dist = []
co = []

for i in range(0,n):
    if i == 0:
        dist.append ( -df[2*i]*fem[2*i] )
    elif  i == n-1:
        dist.append ( -df[2*i-1]*fem[2*i-1] )
    else:
        dist.append ( -df[2*i-1]*(fem[2*i-1]+fem[2*i] ) )
        dist.append ( -df[2*i]*(fem[2*i-1]+fem[2*i]) )

for i in range(0,n-1):
    co.append( cof[2*i+1] * dist[2*i+1] )
    co.append( cof[2*i] * dist[2*i] )

cal = np.array(np.array(dist))
cal = np.vstack((cal,np.array(co)))

"""
cal.append(dist)
cal.append(co)
"""

# shooting

for kk in range(0,9):
    for i in range(0,n):
        if i == 0:
            dist[i] =  -df[2*i]*co[2*i]
        elif  i == n-1:
            dist[2*i-1] = -df[2*i-1]*co[2*i-1]
        else:
            dist[2*i-1] = -df[2*i-1]*(co[2*i-1]+co[2*i])
            dist[2*i]   = -df[2*i]*(co[2*i-1]+co[2*i])

    for i in range(0,n-1):
        co[2*i] = cof[2*i+1] * dist[2*i+1]
        co[2*i+1] = cof[2*i] * dist[2*i]

    cal = np.vstack((cal,np.array(dist)))
    cal = np.vstack((cal,np.array(co)))


md = []
md = np.sum(cal, axis=0)+np.array(fem)


vl = []
ve = []
for i in range(0,len(span)):
    ve.append( -( md[2*i] + md[2*i+1] ) / span[i] )
    ve.append( -( md[2*i] + md[2*i+1] ) / span[i] )
    vl.append( -wd*ly*span[i]/2.0 )
    vl.append( wd*ly*span[i]/2.0 )

v = np.array(ve)+np.array(vl)

# output
np.set_printoptions(precision=3, suppress=True )
print("Calculation of Equivalent frame")
print("DF  =",np.array(df))
print("COF =",np.array(cof))
print("FEM =",np.array(fem))
np.set_printoptions(precision=1, suppress=True )
print("n=",n,"n2=",n2)
print("Sheet=")
print(cal)
print("M=",md)
print("Ve=",np.array(ve))
print("Vl=",np.array(vl))
print("V =",v)
